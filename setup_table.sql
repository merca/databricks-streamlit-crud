-- Unity Catalog Table Setup with Row-Level Security
-- Run this script in Databricks SQL or Databricks notebook

-- 1. Create catalog if it doesn't exist
CREATE CATALOG IF NOT EXISTS main;

-- 2. Create schema if it doesn't exist  
CREATE SCHEMA IF NOT EXISTS main.default;

-- 3. Create the main user_data table with row-level security
CREATE OR REPLACE TABLE main.default.user_data (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY,
    name STRING NOT NULL,
    email STRING NOT NULL,
    department STRING NOT NULL,
    status STRING NOT NULL,
    notes STRING,
    owner_user STRING NOT NULL COMMENT 'User who owns this record - for row-level security',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP(),
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP(),
    CONSTRAINT pk_user_data PRIMARY KEY (id),
    CONSTRAINT unique_email_per_user UNIQUE (email, owner_user)
) 
COMMENT 'User data table with row-level security based on owner_user column'
TBLPROPERTIES (
    'delta.autoOptimize.optimizeWrite' = 'true',
    'delta.autoOptimize.autoCompact' = 'true'
);

-- 4. Create row filter function for row-level security
CREATE OR REPLACE FUNCTION main.default.user_data_row_filter(owner_user STRING)
RETURNS BOOLEAN
LANGUAGE SQL
DETERMINISTIC
COMMENT 'Row filter function to enforce row-level security - users can only see their own data'
RETURN owner_user = current_user();

-- 5. Apply row filter to the table
ALTER TABLE main.default.user_data SET ROW FILTER main.default.user_data_row_filter ON (owner_user);

-- 6. Grant necessary permissions
-- Note: In a production environment, you should grant these permissions 
-- to specific users/groups rather than using wildcards

-- Grant USAGE on catalog and schema
GRANT USAGE ON CATALOG main TO `users`;
GRANT USAGE ON SCHEMA main.default TO `users`;

-- Grant table permissions  
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE main.default.user_data TO `users`;

-- Grant execute permission on the row filter function
GRANT EXECUTE ON FUNCTION main.default.user_data_row_filter TO `users`;

-- 7. Create a view for additional abstraction (optional)
CREATE OR REPLACE VIEW main.default.my_user_data AS
SELECT 
    id,
    name,
    email,
    department,
    status,
    notes,
    created_at,
    updated_at
FROM main.default.user_data
WHERE owner_user = current_user()
COMMENT 'View showing only current user data - additional layer of row-level security';

-- Grant permissions on the view
GRANT SELECT ON VIEW main.default.my_user_data TO `users`;

-- 8. Insert sample data for testing (optional - remove in production)
-- This will create sample records for the current user running the script
INSERT INTO main.default.user_data (name, email, department, status, notes, owner_user)
VALUES 
    ('John Doe', 'john.doe@company.com', 'IT', 'Active', 'Sample IT employee', current_user()),
    ('Jane Smith', 'jane.smith@company.com', 'HR', 'Active', 'Sample HR employee', current_user()),
    ('Bob Johnson', 'bob.johnson@company.com', 'Finance', 'Inactive', 'Sample Finance employee', current_user());

-- 9. Verify the setup
SELECT 
    'Table created successfully' AS status,
    COUNT(*) AS sample_records_for_current_user
FROM main.default.user_data;

-- 10. Show table information
DESCRIBE EXTENDED main.default.user_data;

-- 11. Test the row-level security
SELECT 
    'Row-level security test' AS test_type,
    owner_user,
    COUNT(*) AS accessible_records
FROM main.default.user_data
GROUP BY owner_user
ORDER BY owner_user;